1. Сгенерировать пару ключей/сертификатов (private.pem и public.pem) при помощи OpenSSL.
```
Генерация приватного ключа
openssl genpkey -algorithm RSA -out private.pem
Генерация публичного ключа на основании приватного
openssl rsa -in private.pem -pubout -out public.pem
```
2. Создать скрипт encrypt.sh, который считывает стандартный поток ввода, шифрует его при помощи public.pem через OpenSSL и выводит в стандартный поток вывода.
```
пример файла
rvlt135@rvlt135:~/development/igor-vanin/homework-15$ cat encrypt.sh 
#!/bin/bash

if [ ! -f "public.pem" ]; then
    echo "Ошибка: Файл public.pem не найден."
    exit 1
fi

openssl pkeyutl -pubin -inkey public.pem -encrypt
```

3. Создать скрипт decrypt.sh, который считывает стандартный поток ввода, расшифровывает его при помощи private.pem через OpenSSL и выводит в стандартный поток вывода.
```
rvlt135@rvlt135:~/development/igor-vanin/homework-15$ cat decrypt.sh 
#!/bin/bash

if [ ! -f "private.pem" ]; then
    echo "Ошибка: Файл private.pem не найден."
    exit 1
fi

openssl pkeyutl -inkey private.pem -decrypt
```
Пример шифрования и дешифрования:
```
Cоздаем файл с секретной фразой и шифруем
rvlt135@rvlt135:~/development/igor-vanin/homework-15$ ./encrypt.sh < secrettext.txt > encrypted_data.bin

rvlt135@rvlt135:~/development/igor-vanin/homework-15$ cat secrettext.txt 
test secret devops


Дешифруем:
rvlt135@rvlt135:~/development/igor-vanin/homework-15$ cat encrypted_data.bin | ./decrypt.sh
Enter pass phrase for private.pem:
test secret devops
```
4. Сгенерировать публичный сертификат public-nginx.pem для private.pem через OpenSSL, используя <LASTNAME>.io в качестве Common Name (CN).
5. Настроить Nginx на работу по HTTPS, используя сертификаты из предыдущего задания. Например, чтобы Nginx возвращал домашнюю страницу по HTTPS.
6. Настроить доверие публичному сертификату в браузере и проверить это.
7. А теперь открыть домашнюю страницу Nginx по HTTPS через curl не прибегая к опции -k.
